#pragma rtGlobals=1		// Use modern global access method.#pragma IgorVersion = 6.0//////////////////////////////////////////////////////// calculates the scattering from a rectangular solid// i.e. a parallelepiped with sides a < b < c// // - the user must make sure that the constraints are not violated// otherwise the calculation will not be correct//// From: Mittelbach and Porod, Acta Phys. Austriaca 14 (1961) 185-211.//				equations (1), (13), and (14) (in German!)//// note that the equations listed in Feigin and Svergun appears// to be wrong - they use equation (12), which does not appear to // be a complete orientational average (?)//// a double integral is used, both using Gaussian quadrature// routines that are now included with GaussUtils// 20-pt quadrature appears to be enough, 76 pt is available// by changing the function calls// Core Shell version DS 1stJan/7thJan 2008: accounts for contribution from rims on sides A and B of diff SLDs//Shell on longest edge C is not included in this version////Modified for IgorVersion 6.0 - ACH 1/7/09//////////////////////////////////////////////////////this macro sets up all the necessary parameters and waves that are//needed to calculate the model function.//Proc PlotCSParallpiped(num,qmin,qmax)	Variable num=100, qmin=.001, qmax=.7	Prompt num "Enter number of data points for model: "	Prompt qmin "Enter minimum q-value (A^1) for model: " 	Prompt qmax "Enter maximum q-value (A^1) for model: "	//	Make/O/D/n=(num) xwave_CSParallpiped, ywave_CSParallpiped	xwave_CSParallpiped =  alog(log(qmin) + x*((log(qmax)-log(qmin))/num))	Make/O/D coef_CSParallpiped = {1,35,75,400,10,10,10,2e-6,4e-6,2e-6,-1e-6,6e-6,0.06}			//CH#2	make/o/t parameters_CSParallpiped = {"Scale Factor","Shortest Edge A (A)","B (A)","Longest Edge C (A)","Rim A ()", "Rim B ()","Rim C ()", "SLD A(A^-2)", "SLD B(A^-2)", "SLD C(A^-2)", "SLD P(A^-2)", "SLD Solv(A^-2)", "Incoherent Bgd (cm-1)"}	//CH#3	Edit parameters_CSParallpiped, coef_CSParallpiped		Variable/G root:g_CSParallpiped	g_CSParallpiped := CSParallpiped(coef_CSParallpiped,ywave_CSParallpiped, xwave_CSParallpiped)	Display ywave_CSParallpiped vs xwave_CSParallpiped	ModifyGraph marker=29, msize=2, mode=4	ModifyGraph log=1	Label bottom "q (A\\S-1\\M) "	Label left "I(q) (cm\\S-1\\M)"	AutoPositionWindow/M=1/R=$(WinName(0,1)) $WinName(0,2)		AddModelToStrings("CSParallpiped","coef_CSParallpiped","parameters_CSParallpiped","CSParallpiped")//End////this macro sets up all the necessary parameters and waves that are//needed to calculate the  smeared model function.////no input parameters are necessary, it MUST use the experimental q-values// from the experimental data read in from an AVE/QSIG data file////////////////////////////////////////////////////Proc PlotSmearedCSParallpiped(str)	String str	Prompt str,"Pick the data folder containing the resolution you want",popup,getAList(4)		// if no gQvals wave, data must not have been loaded => abort	if(ResolutionWavesMissingDF(str))		Abort	endif		SetDataFolder $("root:"+str)		// Setup parameter table for model function	Make/O/D smear_coef_CSParallpiped = {1,35,75,400,10,10,10,2e-6,4e-6,2e-6,-1e-6,6e-6,0.06}		//CH#4	make/o/t smear_parameters_CSParallpiped = {"Scale Factor","Shortest Edge A (A)","B (A)","Longest Edge C (A)","Rim A ()", "Rim B ()","Rim C ()", "SLD A(A^-2)", "SLD B(A^-2)", "SLD C(A^-2)", "SLD P(A^-2)", "SLD Solv(A^-2)", "Incoherent Bgd (cm-1)"}	Edit smear_parameters_CSParallpiped,smear_coef_CSParallpiped					//display parameters in a table		// output smeared intensity wave, dimensions are identical to experimental QSIG values	// make extra copy of experimental q-values for easy plotting	Duplicate/O $(str+"_q") smeared_CSParallpiped,smeared_qvals				//	SetScale d,0,0,"1/cm",smeared_CSParallpiped							//	Variable/G gs_CSParallpiped=0	gs_CSParallpiped := fSmearedCSParallpiped(smear_coef_CSParallpiped,smeared_CSParallpiped,smeared_qvals)	//this wrapper fills the STRUCT		Display smeared_CSParallpiped vs smeared_qvals									//	ModifyGraph log=1,marker=29,msize=2,mode=4	Label bottom "q (A\\S-1\\M)"	Label left "I(q) (cm\\S-1\\M)"	AutoPositionWindow/M=1/R=$(WinName(0,1)) $WinName(0,2)	SetDataFolder root:	AddModelToStrings("SmearedCSParallpiped","smear_coef_CSParallpiped","smear_parameters_CSParallpiped","CSParallpiped")EndFunction CSParallpiped(cw,yw,xw) : FitFunc	Wave cw,yw,xw	#if exists("CSParallpipedX")	yw = CSParallpipedX(cw,xw)#else	yw = fCSParallpiped(cw,xw)#endif	return(0)End// calculates the form factor of a rectangular solid// - a double integral - choose points wisely//Function fCSParallpiped(w,x) : FitFunc	Wave w	Variable x//	 Input (fitting) variables are:	//[0] scale factor	//[1] Edge A (A)	//[2] Edge B (A)	//[3] Edge C (A)	//[4] Rim A (A)	//[5] Rim B (A)	//[6] Rim C(A)	//[7] Rim A SLD(A^-2)	//[8] Rim B SLD (A^-2)	//[9] Rim C SLD (A^-2)  not included at the moment	//[10] PPcore SLD (A^-2) 	//[11] Solvent SLD (A^-2)	//[12] incoherent background (cm^-1)//	give them nice names	Variable scale,aa,bb,cc,ta,tb,tc,rhoA,rhoB,rhoC,rhoP,rhosolv,bkg,inten,qq,ii,arg,mu	scale = w[0]	aa = w[1]	bb = w[2]	cc = w[3]	ta  = w[4]	tb  = w[5]	tc  = w[6]   // is 0 at the moment  	rhoA=w[7]   //rim A SLD	rhoB=w[8]   //rim B SLD	rhoC=w[9]    //rim C SLD	rhoP = w[10]   //Parallelpiped core SLD       rhosolv=w[11]  // Solvent SLD      	 bkg = w[12]	//	mu = bb*x		//scale in terms of B//	aa = aa/bb//	cc =cc/bb//	ta= (aa+2*ta)/(b+2*tb)//	tc= (cc+2*tc)/(b+2*tb)		inten = IntegrateFn20(CSPP_Outer,0,1,w,x)//	inten = IntegrateFn76(PP_Outer,0,1,w,x)		inten /= (aa*bb*cc+2*ta*bb*cc+2*aa*tb*cc+2*aa*bb*tc)		//divide by outer volume (=Volume of core+edges)//	inten /= (aa*bb*cc)										// divide by volume here since FF integral has Vol^2 inside	inten *= 1e8		//convert to cm^-1//	inten *= contr*contr	inten *= scale	inten += bkg		Return (inten)End// outer integral// x is the q-value - remember that "mu" in the notation = B*QFunction CSPP_Outer(w,x,dum)	Wave w	Variable x,dum		Variable retVal,mu,mu1,aa,bb,cc,mudum, mudum1, arg  	aa = w[1]	bb = w[2]	cc = w[3]//	ta  = w[4]//	tb  = w[5]//	tc  = w[6]	mu= bb*x//	mu1=(bb+2*tb)*x   				//mu1 needed for including edge C contribution also: none at the moment	mudum = mu*sqrt(1-dum^2)//	mudum1 = mu1*sqrt(1-dum^2)	retval = IntegrateFn20(CSPP_inner,0,1,w,mudum)//	retval = IntegrateFn76(CSPP_inner,0,1,w,mudum)		cc = cc/bb	arg = mu*cc*dum/2	if(arg==0)		retval *= 1	else		retval *= (sin(arg)/arg)*(sin(arg)/arg)	endif		return(retVal)End//returns the integrand of the inner integralFunction CSPP_Inner(w,mu,uu)	Wave w	Variable mu, uu    //mu1 needed for including edge C contribution also	Variable aa,bb,cc, ta,tb,tc, Vin,Vot,V1,V2,V3,rhoA,rhoB,rhoC, rhoP, rhosolv,dr0, drA,drB, drC,retVal,arg0,arg1,arg2,arg3,arg4,arg5,t0,t1,t2, t3, t4,t5	       																								//local variables	//NVAR mu = root:gEvalQval		//already has been converted to S=2*pi*q	aa = w[1]	bb = w[2]	cc = w[3]	 ta = w[4]	 tb = w[5]	 tc = w[6]	rhoA=w[7]	rhoB=w[8]	rhoC=w[9]	rhoP=w[10]	rhosolv=w[11]	dr0=rhoP-rhosolv	drA=rhoA-rhosolv	drB=rhoB-rhosolv	drC=rhoC-rhosolv 	 Vin=(aa*bb*cc)	 Vot=(aa*bb*cc+2*ta*bb*cc+2*aa*tb*cc+2*aa*bb*tc)	 V1=(2*ta*bb*cc)   //  incorrect V1 (aa*bb*cc+2*ta*bb*cc)	 V2=(2*aa*tb*cc)  // incorrect V2(aa*bb*cc+2*aa*tb*cc)//	 V3=(aa*bb*cc+2*aa*bb*tc) 	 aa = aa/bb//	 bb = bb/bb	 ta=(aa+2*ta)/bb	 tb=(aa+2*tb)/bb	//Mu*(1-x^2)^(0.5)	//handle arg=0 separately, as sin(t)/t -> 1 as t->0	//	arg0 = mu*cc*dum/2	arg1 = (mu*aa/2)*sin(Pi*uu/2)	arg2 = (mu/2)*cos(Pi*uu/2)	arg3=  (mu*ta/2)*sin(Pi*uu/2)	arg4=  (mu*tb/2)*cos(Pi*uu/2)	//	if(arg0 ==0)//		t0=1//	else//		t0=sin(arg0)/arg0//	endif		 	if(arg1==0)		t1 = 1	else		t1 = (sin(arg1)/arg1)                //defn for CSPP model sin(arg1)/arg1    test:  (sin(arg1)/arg1)*(sin(arg1)/arg1)   	endif	if(arg2==0)		t2 = 1	else		t2 = (sin(arg2)/arg2)           //defn for CSPP model sin(arg2)/arg2   test: (sin(arg2)/arg2)*(sin(arg2)/arg2)    	endif	if(arg3==0)		t3 = 1	else		t3 = sin(arg3)/arg3	endif	if(arg4==0)		t4 = 1	else		t4 = sin(arg4)/arg4	endif	//	retval =( (dr0*dr0)*(t1*t1)*(t2*t2)*Vin + (drA*drA)*(t3-t1)*(t3-t1)*(t2*t2)*V1+ (drB*drB)*(t1*t1)*(t4-t2)*(t4-t2)*V2  )   // doesnot include contribution from edge C  Incorrect FF	retval =( dr0*t1*t2*Vin + drA*(t3-t1)*t2*V1+ drB*t1*(t4-t2)*V2 )*( dr0*t1*t2*Vin + drA*(t3-t1)*t2*V1+ drB*t1*(t4-t2)*V2 )   //  correct FF : square of sum of phase factors//      retval =t1*t2* dr0*dr0*Vin*Vin    //*( dr0*t1*t2*Vin )   //test case of original PP with no rims	return(retVal); End// this is all there is to the smeared calculation!Function fSmearedCSParallpiped(coefW,yW,xW)	Wave coefW,yW,xW		String str = getWavesDataFolder(yW,0)	String DF="root:"+str+":"		WAVE resW = $(DF+str+"_res")		STRUCT ResSmearAAOStruct fs	WAVE fs.coefW = coefW		WAVE fs.yW = yW	WAVE fs.xW = xW	WAVE fs.resW = resW		Variable err	err = SmearedCSParallpiped(fs)		return (0)End// this is all there is to the smeared calculation!Function SmearedCSParallpiped(s) :FitFunc	Struct ResSmearAAOStruct &s//	the name of your unsmeared model (AAO) is the first argument	Smear_Model_20(CSParallpiped,s.coefW,s.xW,s.yW,s.resW)	return(0)End